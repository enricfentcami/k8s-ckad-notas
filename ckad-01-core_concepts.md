# CORE - Basic commands and shortcuts

https://kubernetes.io/docs/reference/kubectl/cheatsheet/

https://kubernetes.io/docs/reference/kubectl/conventions/

## **1. Get objects: Pods, Deployments, Services ...**

`kubectl get pods`

With complete information (includes which node it is on and its IP):

`kubectl get pods -o wide`

### **1.1. Get detailed information**

`kubectl describe pod my-pod`

### **1.2. Get the YAML definition**

`kubectl get pod my-pod -o yaml`

Store the YAML in file:

`kubectl get pod my-pod -o yaml > pod.yaml`

## **2. Create objects**

### **2.1. Create objects from a YAML file**

`kubectl create -f pod.yaml`

### **2.2. Pod**

`kubectl run nginx --image=nginx` -> Creates a pod

Add arguments `args` to the container, that will be executed on startup. After the `--` are the arguments:
* Bash: `kubectl run pod1 --image=bash -- bash -c "hostname >> /tmp/hostname && sleep 1d"`
  * Check if it worked using the command: `kubectl exec pod1 -- bash -c "cat /tmp/hostname"`
* Sh: `kubectl run pod2 --image=busybox -- /bin/sh -c "hostname >> /tmp/hostname && sleep 1d"`
  * Check if it worked using the command: `kubectl exec pod2 -- sh -c "cat /tmp/hostname"`

Generate Pod Manifest YAML file "-o yaml". Don't create it on Kubernetes with "--dry-run=client":

`kubectl run nginx --image=nginx --dry-run=client -o yaml`

`kubectl run webapp-green --image=kodekloud/webapp-color -o yaml --dry-run=client > pod.yaml`

Pod with labels:

`kubectl run redis --image=redis:alpine --labels=tier=db`

YAML Example:
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: webapp
  labels:
    tier: frontend
spec:
  containers:
    - name: nginx
      image: nginx
      ports:
        - containerPort: 8080
```

If a label is not specified it will default to `run=nginx` (pod name)

#### **2.2.1. Temporal Pods**

Using `-i --rm` you create a temporal Pod that will be deleted when process finishes:

`kubectl run pod-tmp --image=busybox -i --rm -- /bin/sh -c "hostname >> /tmp/hostname && sleep 10"`

Adding argument `-t` it opens the terminal and deletes the pod once the user exists from the container:

`kubectl run pod-tmp --image=busybox -it --rm -- /bin/sh`

#### **2.2.2. Commands and arguments**

From this simple Dockerfile, we can override the commands and arguments in the Pod YAML definition.

```yaml
FROM Ubuntu

ENTRYPOINT ["sleep"]

CMD ["5"]
```

YAML Example:
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: ubuntu-sleeper
spec:
  containers:
    - name: ubuntu-sleeper
      image: ubuntu-sleeper
      command: ["sleep"] # Dockerfile ENTRYPOINT
      args: ["10"] # Dockerfile arguments/CMD
```

### **2.3. ReplicaSet**

ReplicaSet cannot be generated by command, you have to use YAML. In fact, it will be created with the deployment object, create it explicitly is not a common scenario.

Scale and modify the RS by command:

`kubectl scale replicaset webapp --replicas=3`

YAML Example:
```yaml
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: replicaset-1
spec:
  replicas: 2
  selector:
    matchLabels:
      tier: frontend
  template:
    metadata:
      labels:
        tier: frontend
    spec:
      containers:
      - name: nginx
        image: nginx
```

NOTE: If we have previously created Pods that meet the `selector`, the "excess" ones will be eliminated to meet the number of replicas. If there are less than the number of replicas, only those necessary to meet the condition will be created.
Also, if we scale to 0 the ReplicaSet i will delete all pods that meets the selector.

### **2.3. Deployment**

`kubectl create deployment --image=nginx nginx`

Generate a Deployment YAML file "-o yaml". Don't create it in Kubernetes with "--dry-run=client":

`kubectl create deployment --image=nginx nginx --dry-run=client -o yaml`

**Create deployment with replicas**

* Create YAML and add replicas:
  
  `kubectl create deployment --image=nginx nginx --dry-run=client -o yaml > nginx-deployment.yaml`
  
  Open the YAML file and add the necessary replicas, the default is 1. Then launch the creation from the file.

* Create command with replicas:
  
  `kubectl create deployment webapp --image=kodekloud/webapp-color --replicas=3`

* Create without replicas and then scale it:
  
  `kubectl create deployment webapp --image=kodekloud/webapp-color`
  
  `kubectl scale deployment/webapp --replicas=3`

NOTE: Labels cannot be set by command, this does not work:

`kubectl create deployment webapp --image=kodekloud/webapp-color --replicas=3 --labels=app=kodekloud-webapp-color` ->  `unknown flag: --labels`

YAML Example with labels:
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp-deployment
  labels:
    app: webapp
spec:
  replicas: 3
  selector:
    matchLabels:
      app: webapp
  template:
    metadata:
      labels:
        app: webapp
    spec:
      containers:
      - name: nginx
        image: nginx
        ports:
        - containerPort: 8080
```

### **2.4. Service**

A Service is a method for exposing a network application that is running as one or more Pods in your cluster.

This topic will be described in the [Network Services](ckad-06-services_network-01-services.md) section.

Service for redis pod:

`kubectl expose pod redis --name=redis-service --port=6379 --type=ClusterIP --selector=tier=db`

YAML Example:
```yaml
apiVersion: v1
kind: Service
metadata:
  name: webapp-service
  labels:
    app: webapp
spec:
  type: NodePort
  ports:
    - port: 8080
  selector:
    app: webapp
```

Example of a Pod and Service by command:

`kubectl run test-web --image=nginx -l app=front`

`kubectl expose pod test-web --name=test-web-service --port=80 --selector=app=front`

```yaml
apiVersion: v1
kind: Pod
metadata:
  labels:
    app: front
  name: test-web
  namespace: ckad
spec:
  containers:
  - image: nginx
    name: test-web

---

apiVersion: v1
kind: Service
metadata:
  labels:
    app: front
  name: test-web-service
  namespace: ckad
spec:
  ports:
  - port: 80
    protocol: TCP
    targetPort: 80
  selector:
    app: front
```

### **2.5. Namespaces**

`kubectl create namespace test`

Get objects from a namespace:
- `kubectl get pods -n test`
- `kubeclt get pods --namespace=test` (long version)

Get objects from all namespace:
- `kubectl get pods -A`
- `kubectl get pods --all-namespaces` (long version)

YAML Example:
```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: my-namespace
  labels:
    name: my-namespace
```

## **3. Edit objects**

The "vi" system editor will be opened to edit the YAML of the object.

`kubectl edit pod my-pod`

If the change cannot be applied intantly, a copy will be saved in a temporary file that will be indicated. With this file you can recreate the object by doing a previous delete.

## **4. Delete objects**

### Delete from command

`kubectl delete pod my-pod`

Force pod deletion:

`kubectl delete pod my-pod --force`

### Delete from YAML

`kubectl delete -f pod.yaml`

## **5. Kubectl config contexts and namespaces**

See kubeConfig manifest:

`kubectl config view`

See data of available contexts and default namespace:

`kubectl config get-contexts`

Set the default context, cluster change:

`kubectl config use-context my-cluster-name`

Set a new default namespace for the current context (cluster):

`kubectl config set-context --current --namespace=ckad`

IMPORTANT: Very useful in the exam because the questions have their own namespace, but keep in mind to change it if required
